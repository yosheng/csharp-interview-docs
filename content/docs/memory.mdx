---
title: 内存管理
---

## C# 中堆和栈的区别？

| **对比维度**   | **栈（Stack）**                                              | **堆（Heap）**                                           |
| :------------- | :----------------------------------------------------------- | :------------------------------------------------------- |
| **存储内容**   | 值类型（`int`、`struct`）、方法调用的局部变量、参数          | 引用类型（`class`、`string`、`数组`）的对象实例          |
| **分配与释放** | 自动分配/释放（方法结束时立即回收） 速度快（移动栈指针）     | 手动分配/GC自动回收 速度较慢（需内存管理）               |
| **生命周期**   | 与方法调用绑定，作用域结束立即失效                           | 由GC管理，可能存活多轮垃圾回收（分代机制）               |
| **访问速度**   | 极快（直接操作内存，CPU缓存友好）                            | 较慢（需通过引用间接访问）                               |
| **大小限制**   | 固定大小（默认1MB/线程） 栈溢出引发 `StackOverflowException` | 仅受虚拟内存限制（GB级） 溢出引发 `OutOfMemoryException` |
| **典型场景**   | 临时变量、方法参数、线程独占数据                             | 对象实例、集合、共享数据                                 |

## C#可否对内存进行直接的操作？

C#在Unsafe 模式下可以使用指针对内存进行操作, 但在托管模式下不可以使用指针。

1. 在 Visual Studio 开发环境中设置/unsafe（启用不安全模式)编译器选项
   打开项目的“属性”页。
   单击“生成”属性页。
   选中“允许不安全代码”复选框。

2. unsafe关键字表示不安全上下文，该上下文是任何涉及指针的操作所必需的。
   可以在类型或成员的声明中使用 unsafe修饰符。
   因此，类型或成员的整个正文范围均被视为不安全上下文。例如，以下是用 unsafe 修饰符声明的方法：

   ```csharp
   unsafe static void FastCopy(byte[] src, byte[] dst, int count)
   {
   	// Unsafe context: can use pointers here.
   }
   ```

   不安全上下文的范围从参数列表扩展到方法的结尾，因此指针在以下参数列表中也可以使用：
   ```csharp
   unsafe static void FastCopy ( byte* ps, byte* pd, int count ) {...}
   ```

   还可以使用不安全块从而能够使用该块内的不安全代码。例如：
   ```csharp
   unsafe
   {
   	// Unsafe context: can use pointers here.
   }
   ```

   若要编译不安全代码，必须指定 /unsafe编译器选项。
   无法通过公共语言运行库验证不安全代码。

## using() 语法有用吗？什么是IDisposable？

有用，实现了IDisposiable的类在using中创建，using结束后会自定调用该对象的Dispose方法，释放资源。

## using 语句会被编译成什么代码？

```csharp
// 编译前
using (var resource = new FileStream(...)) { ... }

// 编译后（等价于）
FileStream resource = null;
try {
    resource = new FileStream(...);
    ...
} finally {
    resource?.Dispose();
}
```

## CTS、CLS、CLR分别作何解释？

CTS：通用语言系统。CLS：通用语言规范。CLR：公共语言运行库。

## 什么是受管制的代码？

unsafe：非托管代码。不经过CLR运行。

## 什么是托管代码、非托管代码托管代码 (managed code)

托管代码

由公共语言运行库环境（而不是直接由操作系统）执行的代码。托管代码应用程序可以获得公共语言运行库服务，例如自动垃圾回收、运行库类型检查和安全支持等。这些服务帮助提供独立于平台和语言的、统一的托管代码应用程序行为。有关内存管理（内存申请，内存释放，垃圾回收之类的）全部都是.net 的CLR来管理。

非托管代码 (unmanaged code)

在公共语言运行库环境的外部，由操作系统直接执行的代码。非托管代码必须提供自己的垃圾回收、类型检查、安全支持等服务；它与托管代码不同，后者从公共语言运行库中获得这些服务。内存回收要继承IDisposable 接口手动回收。

## GC是什么? 为什么要有GC?

1. GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理.
2. .NET的GC机制有这样两个问题：首先，GC并不是能释放所有的资源。它不能自动释放非托管资源。

GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。

GC就是对“不可达“的对象进行回收，释放内存。

## 如何解决.net中的内存泄漏问题？用到过哪些检测工具？

.NET内存泄漏，更准确的说应该是对象超过生命周期而不能被GC回收。

**常见的内存泄露有：**

- a、静态引用；
- b、控件不使用后未销毁；
- c、调用非托管资源而未释放；
- d、事件注册后未解除注册，等。

**解决方案：**

- (1) Dispose()的使用
  如果使用的对象提供Dispose（）方法，那么当你使用完毕或在必要的地方（比如Exception）调用该方法，特别是对非托管对象,一定要加以调 用，以达到防止泄露的目的。
- (2) using的使用
  using除了引用Dll的功用外，还可以限制对象的适用范围，当超出这个界限后对象自动释放，比如using语句的用途定义一个范围，将在此范围之外释放一个或多个对象。
- (3) 事件的卸载
  这个不是必须的，推荐这样做。之前注册了的事件，关闭画面时应该手动注销，有利于GC回收资源。
- (4) API的调用
  一般的使用API了就意味着使用了非托管资源，需要根据情况手动释放所占资源，特别是在处理大对象时。4.5继承 IDisposable实现自己内存释放接口　Net 如何继承IDisposable接口，实现自己的Dispose()函数
- (5)弱引用（WeakReference ）
  通常情况下，一个实例如果被其他实例引用了，那么他就不会被GC回收，而弱引用的意思是，如果一个实例没有被其他实例引用（真实引用），而仅仅是被弱引用，那么他就会被GC回收。

**诊断工具：**

- a、大多使用windows自带的perfmon.msc，
- b、用过的工具里面CLRProfiler 和dotTrace还行，windbg也还行。不过坦白的说，准确定位比较费劲，最好还是按常规的该Dispose的加Dispose，也可以加 GC.Collect（）

## 内存泄漏和内存溢出的区别是什么？

简单来说，操作系统就像资源分配人员，你要使用内存的时候分给你，你用完了还给它。如果你使用了没有分配给你的内存就是内存溢出，如果你用完了没有了就是内存泄漏。

**会引起的问题：**

内存溢出存在的问题是你用了没有分配给你的内存，系统是不知道的，他又把内存分配给了其他程序，结果就是别人也写了或者读了这个内存。程序可能崩溃。当然也可能没问题，所以内存溢出往往不好查。

内存泄漏的问题就比理解，你没有还给系统，系统的内存就越来越少。直到没有可用内存。

泄漏是占着不用了，溢出是用不该用的地方；溢出一般会出事，泄漏在内存无限时不会出事。

泄漏是说你的程序有BUG 导致内存不释放。溢出是指内存不够用了 导致不够用的原因很多 泄漏只是其中一种。


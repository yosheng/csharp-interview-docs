---
title: 面向对象
index: true
---

## class和struct的区别?

相同点 都可以实现接口

不同点

1. class是引用类型，struct是值类型
2. class允许继承、被继承，struct不允许，只能继承接口
3. class可以初始化变量，struct不可以
4. class可以有无参的构造函数，struct不可以，必须是有参的构造函数，而且在有参的构造函数必须初始化所有成员

使用场景

1. Class比较适合大的和复杂的数据，表现抽象和多级别的对象层次时。
2. Struct适用于作为经常使用的一些数据组合成的新类型，表示诸如点、矩形等主要用来存储数据的轻量级对象时，偏简单值。
3. Struct有性能优势，Class有面向对象的扩展优势。

## 简述一下面向对象的三大特性？

封装、继承、多态。

- 封装：是通过把对象的属性的实现细节隐藏起来，仅对外提供公共的访问方法。
- 继承：是通过子类继承基类、继承抽象类、继承接口实现的。
- 多态：是通过重写基类的override 方法、重写虚方法实现的。 好处是：方便维护、易扩展。 缺点是：比面向过程性能低。

## 抽象类和接口有什么区别？

相同点：都不能直接实例化

不同点：

1. 抽象类用abstract修饰、接口用interface修饰
2. 抽象类中的方法可以实现，也可以不实现，有抽象方法的类一定要用abstract修饰，接口中的方法不允许实现
3. 抽象类只能单继承，接口支持多实现
4. 抽象类有构造方法，接口不能有构造方法
5. 接口只负责功能的定义，通过接口来规范类的，（有哪些功能），而抽象类即负责功能的定义有可以实现功能（实现了哪些功能）

## 什么是虚函数？什么是抽象函数？

###### 定义方式：

- 虚函数：在基类中使用 virtual 关键字定义，可以在派生类中被重写。
- 抽象函数：在抽象类或接口中使用abstract 关键字定义，必须在派生类中被实现。

###### 实现方式：

- 虚函数：在基类中提供默认的实现，派生类可以选择性地重写该函数来提供自己的实现。
- 抽象函数：在抽象类或接口中只定义函数的签名，没有具体的实现，派生类必须实现该函数。

###### 使用场景：

- 虚函数：适用于基类已经有默认实现，但允许派生类根据需要进行修改或扩展的情况。
- 抽象函数：适用于基类无法提供默认实现，而需要派生类必须实现的情况。

###### 调用方式：

- 虚函数：可以通过基类的引用或指针来调用，实际执行的是派生类的重写版本。
- 抽象函数：必须通过派生类的实例来调用。

## 类的执行顺序？

执行顺序：父类，子类，静态块，静态字段，非静态块，非静态字段，构造器，方法

## 接口是否可继承接口？抽象类是否可实现（implements）接口？抽象类是否可继承实现类（concrete class）？

接口可以继承接口，抽象类可以实现接口，抽象类可以继承实现类，但前提是实现类必须有明确的构造函数。

## 继承最大的好处？

对父类成员进行重用，增加代码的可读性、灵活性。

## 请说说引用和对象?

对象和引用时分不开的，对象生成一个地址，放在堆里面，引用则指向这个地址，放在栈里面

## 什么是匿名类，有什么好处？

不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。

```csharp
var x = new {Name="张三",Age=20,Like="LOL"};
```

## 重写和重载的区别?

- 重写方法：关键字用override修饰，派生类重写基类的方法，方法命名、返回类型，参数必须相同
- 重载方法：方法名必须相同，参数列表必须不相同，返回类型可以不相同。
- 作用：重写主要是实现面向对象的多态性、重载主要是实现实例化不同的对象

## C#实现多态的过程中overload 重载与override 重写的区别？

重载：是方法的名称相同，参数或参数类型不同；重载是面向过程的概念。

重写：是对基类中的虚方法进行重写。重写是面向对象的概念。

## 什么时候用重载？什么时候用重写？

当一个类需要用不同的实现来做同一件事情，此时应该用重写，而重载是用不同的输入做同一件事情

## 怎样理解静态变量？静态成员和非静态成员的区别？

静态变量属于类，而不属于对象；并对所有对象所享；静态成员在加类的时候就被加载。

## 属性能在接口中声明吗？

可以，不能有访问修饰符，不能初始化赋值。

## 在项目中为什么使用接口？接口的好处是什么？什么是面向接口开发？

接口是一种约束，描述类的公共方法/公共属性，不能有任何的实现

好处是：结构清晰，类之间通信简单易懂，扩展性好，提高复用性。

面向interface编程，原意是指面向抽象协议编程，实现者在实现时要严格按协议来办。

## 静态方法可以访问非静态变量吗？如果不可以为什么？

静态方法和非静态变量不是同一生命周期，静态方法属于类，非静态变量属于具体的对象，静态方法和具体的对象没有任何关联

## 在.Net中所有可序列化的类都被标记为_?

[serializable]

## C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？

一个是属性，用于存取类的字段，一个是特性，用来标识类，方法等的附加性质

## 能够将非静态的方法覆写成静态方法吗？

答：不能，覆写方法的签名必须与被覆写方法的签名保持一致，除了将virtual改为override。

